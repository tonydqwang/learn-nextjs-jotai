##############################################################################
#
# jotai: atom based state management in react
#
##############################################################################

# intro ####################################################
install
  npm i jotai
Create atoms
  First create primitive and derived atoms to build state.
  Primitive atoms: A primitive atom can be any type: booleans, numbers, strings, objects, arrays, sets, maps, and so on.
    import { atom } from 'jotai'

    const countAtom = atom(0)

    const countryAtom = atom('Japan')

    const citiesAtom = atom(['Tokyo', 'Kyoto', 'Osaka'])

    const animeAtom = atom([
      {
        title: 'Ghost in the Shell',
        year: 1995,
        watched: true
      },
      {
        title: 'Serial Experiments Lain',
        year: 1998,
        watched: false
      }
    ])
  Derived atoms: A derived atom can read from other atoms before returning its own value.
    const progressAtom = atom((get) => {
      const anime = get(animeAtom)
      return anime.filter((item) => item.watched).length / anime.length
    })
Use atoms: Then use atoms within React components to read or write state
  Read and write from same component: When atoms are both read and written within the same component, use the combined useAtom hook for simplicity.
    import { useAtom } from 'jotai'

    const AnimeApp = () => {
      const [anime, setAnime] = useAtom(animeAtom)

      return (
        <>
          <ul>
            {anime.map((item) => (
              <li key={item.title}>{item.title}</li>
            ))}
          </ul>
          <button onClick={() => {
            setAnime((anime) => [
              ...anime,
              {
                title: 'Cowboy Bebop',
                year: 1998,
                watched: false
              }
            ])
          }}>
            Add Cowboy Bebop
          </button>
        <>
      )
    }
  Read and write from separate components: When atom values are only read or written, use the separate useAtomValue and useSetAtom hooks to optimize re-renders.
    import { useAtomValue, useSetAtom } from 'jotai'

    const AnimeList = () => {
      const anime = useAtomValue(animeAtom)

      return (
        <ul>
          {anime.map((item) => (
            <li key={item.title}>{item.title}</li>
          ))}
        </ul>
      )
    }

    const AddAnime = () => {
      const setAnime = useSetAtom(animeAtom)

      return (
        <button onClick={() => {
          setAnime((anime) => [
            ...anime,
            {
              title: 'Cowboy Bebop',
              year: 1998,
              watched: false
            }
          ])
        }}>
          Add Cowboy Bebop
        </button>
      )
    }

    const ProgressTracker = () => {
      const progress = useAtomValue(progressAtom)

      return (
        <div>{Math.trunc(progress * 100)}% watched</div>
      )
    }

    const AnimeApp = () => {
      return (
        <>
          <AnimeList />
          <AddAnime />
          <ProgressTracker />
        </>
      )
    }
Server-side rendering: If server-side rendering with a framework such as Next.js or Waku, make sure to add a Jotai Provider component at the root.
  Next.js (app directory): Create the provider in a separate client component. Then import the provider into the root layout.js server component.
    // ./components/providers.js
    'use client'

    import { Provider } from 'jotai'

    export const Providers = ({ children }) => {
      return (
        <Provider>
          {children}
        </Provider>
      )
    }

    // ./app/layout.js
    import { Providers } from '../components/providers'

    export default function RootLayout({ children }) {
      return (
        <html lang="en">
          <body>
            <Providers>
              {children}
            </Providers>
          </body>
        </html>
      )
    }
  Next.js (pages directory): Create the provider in _app.js.
    // ./pages/_app.js
    import { Provider } from 'jotai'

    export default function App({ Component, pageProps }) {
      return (
        <Provider>
          <Component {...pageProps} />
        </Provider>
      )
    }
API overview: Core
  Jotai has a very minimal API and is TypeScript oriented. 
  It is as simple to use as React's integrated useState hook, but all state is globally accessible, derived state is easy to implement, and 
  unnecessary re-renders are automatically eliminated.
    import { atom, useAtom } from 'jotai'

    // Create your atoms and derivatives
    const textAtom = atom('hello')
    const uppercaseAtom = atom(
      (get) => get(textAtom).toUpperCase()
    )

    // Use them anywhere in your app
    const Input = () => {
      const [text, setText] = useAtom(textAtom)
      const handleChange = (e) => setText(e.target.value)
      return (
        <input value={text} onChange={handleChange} />
      )
    }

    const Uppercase = () => {
      const [uppercase] = useAtom(uppercaseAtom)
      return (
        <div>Uppercase: {uppercase}</div>
      )
    }

    // Now you have the components
    const App = () => {
      return (
        <>
          <Input />
          <Uppercase />
        </>
      )
    }
Utilities
  The Jotai package also includes a jotai/utils bundle. These extra functions add support for persisting an atom in localStorage, 
  hydrating an atom during server-side rendering, creating atoms with Redux-like reducers and action types, and much more.
    import { useAtom } from 'jotai'
    import { atomWithStorage } from 'jotai/utils'

    // Set the string key and the initial value
    const darkModeAtom = atomWithStorage('darkMode', false)

    const Page = () => {
      // Consume persisted state like any other atom
      const [darkMode, setDarkMode] = useAtom(darkModeAtom)
      const toggleDarkMode = () => setDarkMode(!darkMode)
      return (
        <>
          <h1>Welcome to {darkMode ? 'dark' : 'light'} mode!</h1>
          <button onClick={toggleDarkMode}>toggle theme</button>
        </>
      )
    }
Extensions
  There are also separate packages for each official extension: tRPC, Immer, Query, XState, URQL, Optics, Relay, location, molecules, cache, and more.
  Some extensions provide new atom types with alternate write functions such as atomWithImmer (Immer) or atomWithMachine (XState).
  Others provide new atom types with two-way data binding such as atomWithLocation or atomWithHash
    import { useAtom } from 'jotai'
    import { atomWithImmer } from 'jotai-immer'

    // Create a new atom with an immer-based write function
    const countAtom = atomWithImmer(0)

    const Counter = () => {
      const [count] = useAtom(countAtom)
      return (
        <div>count: {count}</div>
      )
    }

    const Controls = () => {
      // setCount === update: (draft: Draft<Value>) => void
      const [, setCount] = useAtom(countAtom)
      const increment = () => setCount((c) => (c = c + 1))
      return (
        <button onClick={increment}>+1</button>
      )
    }
Learn more
  Check out the free Egghead course by Daishi, the creator of Jotai.
  https://egghead.io/courses/manage-application-state-with-jotai-atoms-2c3a29f0


# core: store #####################################################
createStore
  This function is to create a new empty store. The store can be used to pass in Provider.
  The store has three methods: get for getting atom values, set for setting atom values, and sub for subscribing to atom changes.
    const myStore = createStore()
    
    const countAtom = atom(0) # create atom
    myStore.set(countAtom, 1) # set atom to store with value
    const unsub = myStore.sub(countAtom, () => { # listen for change
      console.log('countAtom value is changed to', myStore.get(countAtom))
    })
    // unsub() to unsubscribe

    const Root = () => ( # add to store
      <Provider store={myStore}>
        <App />
      </Provider>
    )
getDefaultStore
  const defaultStore = getDefaultStore()
end of core:store

# core: provider #####################################################
Provider
  The Provider component is to provide state for a component sub tree.
  Multiple Providers can be used for multiple subtrees, and they can even be nested. This works just like React Context.
  If an atom is used in a tree without a Provider, it will use the default state. This is so-called provider-less mode.
  Providers are useful for three reasons:
    To provide a different state for each sub tree.
    To accept initial values of atoms.
    To clear all atoms by remounting.
  sample code
    const SubTree = () => (
      <Provider>
        <Child />
      </Provider>
    )
  Signatures
    const Provider: React.FC<{
      store?: Store
    }>
  Atom configs don't hold values. Atom values reside in separate stores. 
  A Provider is a component that contains a store and provides atom values under the component tree. 
  A Provider works like React context provider. If you don't use a Provider, it works as provider-less mode with a default store.
  A Provider will be necessary if we need to hold different atom values for different component trees. 
  Provider can take an optional prop store.
    const Root = () => (
      <Provider>
        <App />
      </Provider>
    )
  store prop
    A Provider accepts an optional prop store that you can use for the Provider subtree.
      const myStore = createStore()

      const Root = () => (
        <Provider store={myStore}>
          <App />
        </Provider>
      )
useStore
  This hook returns a store within the component tree.
    const Component = () => {
      const store = useStore()
        // ...
      }